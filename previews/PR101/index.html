<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · LogDensityProblems.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LogDensityProblems.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Working-with-log-density-problems"><span>Working with log density problems</span></a></li><li><a class="tocitem" href="#Using-the-TransformVariables-package"><span>Using the TransformVariables package</span></a></li><li><a class="tocitem" href="#Manual-unpacking-and-transformation"><span>Manual unpacking and transformation</span></a></li><li><a class="tocitem" href="#Automatic-differentiation"><span>Automatic differentiation</span></a></li><li><a class="tocitem" href="#Manually-calculated-derivatives"><span>Manually calculated derivatives</span></a></li><li class="toplevel"><a class="tocitem" href="#Various-utilities"><span>Various utilities</span></a></li><li class="toplevel"><a class="tocitem" href="#log-density-api"><span>Log densities API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tpapp/LogDensityProblems.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This package serves two purposes:</p><ol><li><p>Introduce a common API for packages that operate on <em>log densities</em>, which for these purposes are black box <span>$\mathbb{R}^n \to \mathbb{R}$</span> mappings. Using the interface of introduced in this package, you can query <span>$n$</span>, evaluate the log density and optionally its gradient, and determine if a particular object supports these methods using traits. <strong>This usage is relevant primarily for package developers</strong> who write generic algorithms that use (log) densities that correspond to posteriors and likelihoods, eg <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">MCMC</a>, <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation">MAP</a>, <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">ML</a>. An example is <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>. This is documented in <a href="#log-density-api">the API section</a>.</p></li><li><p>Make it easier for <strong>users who want to perform inference</strong> using the above methods (and packages) to</p><ul><li><em>define their own log densities</em>, either taking a vector of real numbers as input, or extracting and transforming parameters using the <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a> package,</li><li><em>obtain gradients</em> of these log densities using one of the supported <em>automatic differentiation</em> packages of Julia.</li></ul></li></ol><p>This is documented in the next section, with a worked example.</p><p>For the purposes of this package, <em>log densities</em> are still valid when shifted by a constant that may be unknown, but is consistent within calls. This is necessary for Bayesian inference, where log posteriors are usually calculated up to a constant. See <a href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> for details.</p><h1 id="Working-with-log-density-problems"><a class="docs-heading-anchor" href="#Working-with-log-density-problems">Working with log density problems</a><a id="Working-with-log-density-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-log-density-problems" title="Permalink"></a></h1><p>Consider an inference problem where IID draws are obtained from a normal distribution,</p><p class="math-container">\[x_i \sim N(\mu, \sigma)\]</p><p>for <span>$i = 1, \dots, N$</span>. It can be shown that the <em>log likelihood</em> conditional on <span>$\mu$</span> and <span>$\sigma$</span> is</p><p class="math-container">\[\ell = -N\log \sigma - \sum_{i = 1}^N \frac{(x-\mu)^2}{2\sigma^2} =
-N\left( \log \sigma + \frac{S + (\bar{x} - \mu)^2}{2\sigma^2} \right)\]</p><p>where we have dropped constant terms, and defined the sufficient statistics</p><p class="math-container">\[\bar{x} = \frac{1}{N} \sum_{i = 1}^N x_i\]</p><p>and</p><p class="math-container">\[S = \frac{1}{N} \sum_{i = 1}^N (x_i - \bar{x})^2\]</p><p>Finally, we use priors</p><p class="math-container">\[\mu \sim N(0, 5), \sigma \sim N(0, 2)\]</p><p>which yield the log prior</p><p class="math-container">\[-\sigma^2/8 - \mu^2/50\]</p><p>which is added to the log likelihood to obtain the log posterior.</p><p>It is useful to define a <em>callable</em> that implements this, taking some vector <code>x</code> as an input and calculating the summary statistics, then, when called with a <code>NamedTuple</code> containing the parameters, evaluating to the log posterior.</p><pre><code class="language-julia hljs">using Statistics, UnPack # imported for our implementation

struct NormalPosterior{T} # contains the summary statistics
    N::Int
    x̄::T
    S::T
end

# calculate summary statistics from a data vector
function NormalPosterior(x::AbstractVector)
    NormalPosterior(length(x), mean(x), var(x; corrected = false))
end

# define a callable that unpacks parameters, and evaluates the log likelihood
function (problem::NormalPosterior)(θ)
    @unpack μ, σ = θ
    @unpack N, x̄, S = problem
    loglikelihood = -N * (log(σ) + (S + abs2(μ - x̄)) / (2 * abs2(σ)))
    logprior = - abs2(σ)/8 - abs2(μ)/50
    loglikelihood + logprior
end

problem = NormalPosterior(randn(100))</code></pre><p>Let&#39;s try out the posterior calculation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; problem((μ = 0.0, σ = 1.0))</code><code class="nohighlight hljs ansi" style="display:block;">-48.60297471151442</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Just evaluating your log density function like above is a great way to test and benchmark your implementation. See the “Performance Tips” section of the Julia manual for optimization advice.</p></div></div><h2 id="Using-the-TransformVariables-package"><a class="docs-heading-anchor" href="#Using-the-TransformVariables-package">Using the TransformVariables package</a><a id="Using-the-TransformVariables-package-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-TransformVariables-package" title="Permalink"></a></h2><p>In our example, we require <span>$\sigma &gt; 0$</span>, otherwise the problem is meaningless. However, many MCMC samplers prefer to operate on <em>unconstrained</em> spaces <span>$\mathbb{R}^n$</span>. The TransformVariables package was written to transform unconstrained to constrained spaces, and help with the log Jacobian correction (more on that later). That package has detailed documentation, now we just define a transformation from a length 2 vector to a <code>NamedTuple</code> with fields <code>μ</code> (unconstrained) and <code>σ &gt; 0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since version 1.0, TransformedLogDensity has been moved to the package TransformedLogDensities.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LogDensityProblems, TransformVariables, TransformedLogDensities</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℓ = TransformedLogDensity(as((μ = asℝ, σ = asℝ₊)), problem)</code><code class="nohighlight hljs ansi" style="display:block;">TransformedLogDensity of dimension 2</code></pre><p>Then we can query the dimension of this problem, and evaluate the log density:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; LogDensityProblems.dimension(ℓ)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; LogDensityProblems.logdensity(ℓ, zeros(2))</code><code class="nohighlight hljs ansi" style="display:block;">-48.60297471151442</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Before running time-consuming algorithms like MCMC, it is advisable to test and benchmark your log density evaluations separately. The same applies to <a href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> and <a href="#LogDensityProblems.logdensity_gradient_and_hessian"><code>LogDensityProblems.logdensity_gradient_and_hessian</code></a>.</p></div></div><h2 id="Manual-unpacking-and-transformation"><a class="docs-heading-anchor" href="#Manual-unpacking-and-transformation">Manual unpacking and transformation</a><a id="Manual-unpacking-and-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-unpacking-and-transformation" title="Permalink"></a></h2><p>If you prefer to implement the transformation yourself, you just have to define the following three methods for your problem: declare that it can evaluate log densities (but not their gradient, hence the <code>0</code> order), allow the dimension of the problem to be queried, and then finally code the density calculation with the transformation. (Note that using <code>TransformedLogDensities.TransformedLogDensity</code> takes care of all of these for you, as shown above).</p><pre><code class="language-julia hljs">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{0}()
end

LogDensityProblems.dimension(::NormalPosterior) = 2

function LogDensityProblems.logdensity(problem::NormalPosterior, x)
    μ, logσ = x
    σ = exp(logσ)
    problem((μ = μ, σ = σ)) + logσ
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; LogDensityProblems.logdensity(problem, zeros(2))</code><code class="nohighlight hljs ansi" style="display:block;">-48.60297471151442</code></pre><p>Here we use the exponential function to transform from <span>$\mathbb{R}$</span> to the positive reals, but this requires that we correct the log density with the <em>logarithm</em> of the Jacobian, which here happens to be <span>$\log(\sigma)$</span>.</p><h2 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h2><p>Using either definition, you can transform to another object which is capable of evaluating the <em>gradient</em>, using automatic differentiation. For this, you need the <a href="https://github.com/tpapp/LogDensityProblemsAD.jl">LogDensityProblemsAD.jl</a> package.</p><p>Now observe that we can obtain gradients, too:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import ForwardDiff</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LogDensityProblemsAD</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∇ℓ = ADgradient(:ForwardDiff, ℓ)</code><code class="nohighlight hljs ansi" style="display:block;">ForwardDiff AD wrapper for TransformedLogDensity of dimension 2, w/ chunk size 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; LogDensityProblems.capabilities(∇ℓ)</code><code class="nohighlight hljs ansi" style="display:block;">LogDensityProblems.LogDensityOrder{1}()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; LogDensityProblems.logdensity_and_gradient(∇ℓ, zeros(2))</code><code class="nohighlight hljs ansi" style="display:block;">(-48.60297471151442, [2.8381559225185673, -2.294050576971158])</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Before version 2.0, <code>ADgradient</code> was part of this package. To update older code, just add <code>using LogDensityProblemsAD</code>.</p></div></div><h2 id="Manually-calculated-derivatives"><a class="docs-heading-anchor" href="#Manually-calculated-derivatives">Manually calculated derivatives</a><a id="Manually-calculated-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Manually-calculated-derivatives" title="Permalink"></a></h2><p>If you prefer not to use automatic differentiation, you can wrap your own derivatives following the template</p><pre><code class="language-julia hljs">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{1}() # can do gradient
end

LogDensityProblems.dimension(::NormalPosterior) = 2 # for this problem

function LogDensityProblems.logdensity_and_gradient(problem::NormalPosterior, x)
    logdens = ...
    grad = ...
    logdens, grad
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the gradient is a mutable vector (eg <code>Vector</code>), it should not be reused for another purpose. Practically, each call to <a href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> should allocate a new one, or use immutables like <code>StaticArrays.SVector</code> for small dimensions.</p></div></div><h1 id="Various-utilities"><a class="docs-heading-anchor" href="#Various-utilities">Various utilities</a><a id="Various-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Various-utilities" title="Permalink"></a></h1><p>You may find these utilities useful for debugging and optimization.</p><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.stresstest" href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stresstest(f, ℓ; N, rng, scale)
</code></pre><p>Test <code>ℓ</code> with random values.</p><p><code>N</code> random vectors are drawn from a standard multivariate Cauchy distribution, scaled with <code>scale</code> (which can be a scalar or a conformable vector).</p><p>Each random vector is then used as an argument in <code>f(ℓ, ...)</code>. <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>, <a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a>, and <a href="#LogDensityProblems.logdensity_gradient_and_hessian"><code>logdensity_gradient_and_hessian</code></a> are recommended for <code>f</code>.</p><p>In case the call produces an error, the value is recorded as a failure, which are returned by the function.</p><p>Not exported, but part of the API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/utilities.jl#L32">source</a></section></article><h1 id="log-density-api"><a class="docs-heading-anchor" href="#log-density-api">Log densities API</a><a id="log-density-api-1"></a><a class="docs-heading-anchor-permalink" href="#log-density-api" title="Permalink"></a></h1><p>Use the functions below for evaluating gradients and querying their dimension and other information. These symbols are not exported, as they are mostly used by package developers and in any case would need to be <code>import</code>ed or qualified to add methods to.</p><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.capabilities" href="#LogDensityProblems.capabilities"><code>LogDensityProblems.capabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">capabilities(T)
</code></pre><p>Test if the type (or a value, for convenience) supports the log density interface.</p><p>When <code>nothing</code> is returned, it doesn&#39;t support this interface. When <code>LogDensityOrder{K}()</code> is returned (typically with <code>K == 0</code>, <code>K = 1</code>, or <code>K == 2</code>), derivatives up to order <code>K</code> are supported. <em>All other return values are invalid</em>.</p><p><strong>Interface description</strong></p><p>The following methods need to be implemented for the interface:</p><ol><li><p><a href="#LogDensityProblems.dimension"><code>dimension</code></a> returns the <em>dimension</em> of the domain,</p></li><li><p><a href="#LogDensityProblems.logdensity"><code>logdensity</code></a> evaluates the log density at a given point.</p></li><li><p><a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a> when <code>K ≥ 1</code>.</p></li><li><p><a href="#LogDensityProblems.logdensity_gradient_and_hessian"><code>logdensity_gradient_and_hessian</code></a> when <code>K ≥ 2</code>.</p></li></ol><p>See also <a href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> for stress testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.LogDensityOrder" href="#LogDensityProblems.LogDensityOrder"><code>LogDensityProblems.LogDensityOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LogDensityOrder{K}</code></pre><p>A trait that means that a log density supports evaluating derivatives up to order <code>K</code>.</p><p>Typical values for <code>K</code> are <code>0</code> (just the log density) and <code>1</code> (log density and gradient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.dimension" href="#LogDensityProblems.dimension"><code>LogDensityProblems.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimension(ℓ)</code></pre><p>Dimension of the input vectors <code>x</code> for log density <code>ℓ</code>. See <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>, <a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is <em>distinct</em> from <code>TransformedVariables.dimension</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.logdensity" href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logdensity(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return a real number, which may or may not be finite (can also be <code>NaN</code>). Non-finite values other than <code>-Inf</code> are invalid but do not error, caller should deal with these appropriately.</p><p><strong>Note about constants</strong></p><p>Log densities can be shifted by <em>the same constant</em>, as long as it is consistent between calls. For example,</p><pre><code class="language-julia hljs">logdensity(::StandardMultivariateNormal) = -0.5 * sum(abs2, x)</code></pre><p>is a valid implementation for some callable <code>StandardMultivariateNormal</code> that would implement the standard multivariate normal distribution (dimension <span>$k$</span>) with pdf</p><p class="math-container">\[(2\pi)^{-k/2} e^{-x&#39;x/2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L82-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.logdensity_and_gradient" href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logdensity_and_gradient(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> and its gradient at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return two values:</p><ul><li><p>the log density as real number, which equivalent to <code>logdensity(ℓ, x)</code></p></li><li><p><em>if</em> the log density is finite, the gradient, an <code>::AbstractVector</code> of real numbers,  otherwise this value is arbitrary and should be ignored.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Caller may assume ownership of results, ie that the gradient vector will not be overwritten or reused for a different purpose.</p></div></div><p>The first argument (the log density) can be shifted by a constant, see the note for <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L108-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.logdensity_gradient_and_hessian" href="#LogDensityProblems.logdensity_gradient_and_hessian"><code>LogDensityProblems.logdensity_gradient_and_hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logdensity_gradient_and_hessian(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code>, its gradient, and Hessian at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return three values:</p><ul><li><p>the log density as real number, which equivalent to <code>logdensity(ℓ, x)</code></p></li><li><p><em>if</em> the log density is finite, the gradient, an <code>::AbstractVector</code> of real numbers,  otherwise this value is arbitrary and should be ignored.</p></li><li><p><em>if</em> the log density is finite, the Hessian, an <code>::AbstractMatrix</code> of real numbers,  otherwise this value is arbitrary and should be ignored.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Caller may assume ownership of results, ie that the gradient and Hessian will not be overwritten or reused for a different purpose.</p></div></div><p>The first argument (the log density) can be shifted by a constant, see the note for <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/b3130d82a3d8a71f9c18866c3e0f5892e7326cd6/src/LogDensityProblems.jl#L130-L152">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 9 January 2023 13:23">Monday 9 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
