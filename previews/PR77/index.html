<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · LogDensityProblems.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LogDensityProblems.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Working-with-log-density-problems"><span>Working with log density problems</span></a></li><li><a class="tocitem" href="#Using-the-TransformVariables-package"><span>Using the TransformVariables package</span></a></li><li><a class="tocitem" href="#Manual-unpacking-and-transformation"><span>Manual unpacking and transformation</span></a></li><li><a class="tocitem" href="#Automatic-differentiation"><span>Automatic differentiation</span></a></li><li><a class="tocitem" href="#Manually-calculated-derivatives"><span>Manually calculated derivatives</span></a></li><li class="toplevel"><a class="tocitem" href="#Various-utilities"><span>Various utilities</span></a></li><li class="toplevel"><a class="tocitem" href="#log-density-api"><span>Log densities API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tpapp/LogDensityProblems.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This package serves two purposes:</p><ol><li><p>Introduce a common API for packages that operate on <em>log densities</em>, which for these purposes are black box <span>$\mathbb{R}^n \to \mathbb{R}$</span> mappings. Using the interface of introduced in this package, you can query <span>$n$</span>, evaluate the log density and optionally its gradient, and determine if a particular object supports these methods using traits. <strong>This usage is relevant primarily for package developers</strong> who write generic algorithms that use (log) densities that correspond to posteriors and likelihoods, eg <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">MCMC</a>, <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation">MAP</a>, <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">ML</a>. An example is <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>. This is documented in <a href="#log-density-api">the API section</a>.</p></li><li><p>Make it easier for <strong>users who want to perform inference</strong> using the above methods (and packages) to</p><ul><li><em>define their own log densities</em>, either taking a vector of real numbers as input, or extracting and transforming parameters using the <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a> package,</li><li><em>obtain gradients</em> of these log densities using one of the supported <em>automatic differentiation</em> packages of Julia.</li></ul></li></ol><p>This is documented in the next section, with a worked example.</p><p>For the purposes of this package, <em>log densities</em> are still valid when shifted by a constant that may be unknown, but is consistent within calls. This is necessary for Bayesian inference, where log posteriors are usually calculated up to a constant. See <a href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> for details.</p><h1 id="Working-with-log-density-problems"><a class="docs-heading-anchor" href="#Working-with-log-density-problems">Working with log density problems</a><a id="Working-with-log-density-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-log-density-problems" title="Permalink"></a></h1><p>Consider an inference problem where IID draws are obtained from a normal distribution,</p><p class="math-container">\[x_i \sim N(\mu, \sigma)\]</p><p>for <span>$i = 1, \dots, N$</span>. It can be shown that the <em>log likelihood</em> conditional on <span>$\mu$</span> and <span>$\sigma$</span> is</p><p class="math-container">\[\ell = -N\log \sigma - \sum_{i = 1}^N \frac{(x-\mu)^2}{2\sigma^2} =
-N\left( \log \sigma + \frac{S + (\bar{x} - \mu)^2}{2\sigma^2} \right)\]</p><p>where we have dropped constant terms, and defined the sufficient statistics</p><p class="math-container">\[\bar{x} = \frac{1}{N} \sum_{i = 1}^N x_i\]</p><p>and</p><p class="math-container">\[S = \frac{1}{N} \sum_{i = 1}^N (x_i - \bar{x})^2\]</p><p>Finally, we use priors</p><p class="math-container">\[\mu \sim N(0, 5), \sigma \sim N(0, 2)\]</p><p>which yield the log prior</p><p class="math-container">\[-\sigma^2/8 - \mu^2/50\]</p><p>which is added to the log likelihood to obtain the log posterior.</p><p>It is useful to define a <em>callable</em> that implements this, taking some vector <code>x</code> as an input and calculating the summary statistics, then, when called with a <code>NamedTuple</code> containing the parameters, evaluating to the log posterior.</p><pre><code class="language-julia">using Statistics, UnPack # imported for our implementation

struct NormalPosterior{T} # contains the summary statistics
    N::Int
    x̄::T
    S::T
end

# calculate summary statistics from a data vector
function NormalPosterior(x::AbstractVector)
    NormalPosterior(length(x), mean(x), var(x; corrected = false))
end

# define a callable that unpacks parameters, and evaluates the log likelihood
function (problem::NormalPosterior)(θ)
    @unpack μ, σ = θ
    @unpack N, x̄, S = problem
    loglikelihood = -N * (log(σ) + (S + abs2(μ - x̄)) / (2 * abs2(σ)))
    logprior = - abs2(σ)/8 - abs2(μ)/50
    loglikelihood + logprior
end

problem = NormalPosterior(randn(100))</code></pre><p>Let&#39;s try out the posterior calculation:</p><pre><code class="language-julia-repl">julia&gt; problem((μ = 0.0, σ = 1.0))
-50.651937717496715</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Just evaluating your log density function like above is a great way to test and benchmark your implementation. See the “Performance Tips” section of the Julia manual for optimization advice.</p></div></div><h2 id="Using-the-TransformVariables-package"><a class="docs-heading-anchor" href="#Using-the-TransformVariables-package">Using the TransformVariables package</a><a id="Using-the-TransformVariables-package-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-TransformVariables-package" title="Permalink"></a></h2><p>In our example, we require <span>$\sigma &gt; 0$</span>, otherwise the problem is meaningless. However, many MCMC samplers prefer to operate on <em>unconstrained</em> spaces <span>$\mathbb{R}^n$</span>. The TransformVariables package was written to transform unconstrained to constrained spaces, and help with the log Jacobian correction (more on that later). That package has detailed documentation, now we just define a transformation from a length 2 vector to a <code>NamedTuple</code> with fields <code>μ</code> (unconstrained) and <code>σ &gt; 0</code>.</p><pre><code class="language-julia-repl">julia&gt; using LogDensityProblems, TransformVariables

julia&gt; ℓ = TransformedLogDensity(as((μ = asℝ, σ = asℝ₊)), problem)
TransformedLogDensity of dimension 2</code></pre><p>Then we can query the dimension of this problem, and evaluate the log density:</p><pre><code class="language-julia-repl">julia&gt; LogDensityProblems.dimension(ℓ)
2

julia&gt; LogDensityProblems.logdensity(ℓ, zeros(2))
-50.651937717496715</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Before running time-consuming algorithms like MCMC, it is advisable to test and benchmark your log density evaluations separately. The same applies to <a href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.TransformedLogDensity" href="#LogDensityProblems.TransformedLogDensity"><code>LogDensityProblems.TransformedLogDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TransformedLogDensity(transformation, log_density_function)</code></pre><p>A problem in Bayesian inference. Vectors of length compatible with the dimension (obtained from <code>transformation</code>) are transformed into a general object <code>θ</code> (unrestricted type, but a named tuple is recommended for clean code), correcting for the log Jacobian determinant of the transformation.</p><p><code>log_density_function(θ)</code> is expected to return <em>real numbers</em>. For zero densities or infeasible <code>θ</code>s, <code>-Inf</code> or similar should be returned, but for efficiency of inference most methods recommend using <code>transformation</code> to avoid this. It is recommended that <code>log_density_function</code> is a callable object that also encapsulates the data for the problem.</p><p>Use the property accessors <code>ℓ.transformation</code> and <code>ℓ.log_density_function</code> to access the arguments of <code>ℓ::TransformedLogDensity</code>, these are part of the public API.</p><p><strong>Usage note</strong></p><p>This is the most convenient way to define log densities, as <code>capabilities</code>, <code>logdensity</code>, and <code>dimension</code> are automatically defined. To obtain a type that supports derivatives, use <a href="#LogDensityProblems.ADgradient"><code>ADgradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L135-L156">source</a></section></article><h2 id="Manual-unpacking-and-transformation"><a class="docs-heading-anchor" href="#Manual-unpacking-and-transformation">Manual unpacking and transformation</a><a id="Manual-unpacking-and-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-unpacking-and-transformation" title="Permalink"></a></h2><p>If you prefer to implement the transformation yourself, you just have to define the following three methods for your problem: declare that it can evaluate log densities (but not their gradient, hence the <code>0</code> order), allow the dimension of the problem to be queried, and then finally code the density calculation with the transformation. (Note that using <a href="#LogDensityProblems.TransformedLogDensity"><code>TransformedLogDensity</code></a> takes care of all of these for you, as shown above).</p><pre><code class="language-julia">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{0}()
end

LogDensityProblems.dimension(::NormalPosterior) = 2

function LogDensityProblems.logdensity(problem::NormalPosterior, x)
    μ, logσ = x
    σ = exp(logσ)
    problem((μ = μ, σ = σ)) + logσ
end</code></pre><pre><code class="language-julia-repl">julia&gt; LogDensityProblems.logdensity(problem, zeros(2))
-50.651937717496715</code></pre><p>Here we use the exponential function to transform from <span>$\mathbb{R}$</span> to the positive reals, but this requires that we correct the log density with the <em>logarithm</em> of the Jacobian, which here happens to be <span>$\log(\sigma)$</span>.</p><h2 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h2><p>Using either definition, you can now transform to another object which is capable of evaluating the <em>gradient</em>, using automatic differentiation. The wrapper for this is</p><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.ADgradient" href="#LogDensityProblems.ADgradient"><code>LogDensityProblems.ADgradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ADgradient(kind, P; kwargs...)
</code></pre><p>Wrap <code>P</code> using automatic differentiation to obtain a gradient.</p><p><code>kind</code> is usually a <code>Val</code> type with a symbol that refers to a package, for example</p><pre><code class="language-julia">ADgradient(Val(:ForwardDiff), P)
ADgradient(Val(:ReverseDiff), P)
ADgradient(Val(:Zygote), P)</code></pre><p>Some methods may be loaded only conditionally after the relevant package is loaded (eg <code>using Zygote</code>).</p><p>The symbol can also be used directly as eg</p><pre><code class="language-julia">ADgradient(:ForwardDiff, P)</code></pre><p>and should mostly be equivalent if the compiler manages to fold the constant.</p><p>The function <code>parent</code> can be used to retrieve the original argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L197">source</a></section><section><div><pre><code class="nohighlight">ADgradient(:ForwardDiff, ℓ; chunk, gradientconfig)
ADgradient(Val(:ForwardDiff), ℓ; chunk, gradientconfig)</code></pre><p>Wrap a log density that supports evaluation of <code>Value</code> to handle <code>ValueGradient</code>, using <code>ForwardDiff</code>.</p><p>Keywords are passed on to <code>ForwardDiff.GradientConfig</code> to customize the setup. In particular, chunk size can be set with a <code>chunk</code> keyword argument (accepting an integer or a <code>ForwardDiff.Chunk</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/AD_ForwardDiff.jl#L31-L41">source</a></section><section><div><pre><code class="nohighlight">ADgradient(:Tracker, ℓ)
ADgradient(Val(:Tracker), ℓ)</code></pre><p>Gradient using algorithmic/automatic differentiation via Tracker.</p><p>This package has been deprecated in favor of Zygote, but we keep the interface available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/AD_Tracker.jl#L11-L18">source</a></section><section><div><pre><code class="nohighlight">ADgradient(:Zygote, ℓ)
ADgradient(Val(:Zygote), ℓ)</code></pre><p>Gradient using algorithmic/automatic differentiation via Zygote.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/AD_Zygote.jl#L7-L12">source</a></section></article><p>Now observe that we can obtain gradients, too:</p><pre><code class="language-julia-repl">julia&gt; import ForwardDiff

julia&gt; ∇ℓ = ADgradient(:ForwardDiff, ℓ)
ForwardDiff AD wrapper for TransformedLogDensity of dimension 2, w/ chunk size 2

julia&gt; LogDensityProblems.capabilities(∇ℓ)
LogDensityProblems.LogDensityOrder{1}()

julia&gt; LogDensityProblems.logdensity_and_gradient(∇ℓ, zeros(2))
(-50.651937717496715, [-1.705049596156234, 1.8038754349934232])</code></pre><h2 id="Manually-calculated-derivatives"><a class="docs-heading-anchor" href="#Manually-calculated-derivatives">Manually calculated derivatives</a><a id="Manually-calculated-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Manually-calculated-derivatives" title="Permalink"></a></h2><p>If you prefer not to use automatic differentiation, you can wrap your own derivatives following the template</p><pre><code class="language-julia">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{1}() # can do gradient
end

LogDensityProblems.dimension(::NormalPosterior) = 2 # for this problem

function LogDensityProblems.logdensity_and_gradient(problem::NormalPosterior, x)
    logdens = ...
    grad = ...
    logdens, grad
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the gradient is a mutable vector (eg <code>Vector</code>), it should not be reused for another purpose. Practically, each call to <a href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> should allocate a new one, or use immutables like <code>StaticArrays.SVector</code> for small dimensions.</p></div></div><h1 id="Various-utilities"><a class="docs-heading-anchor" href="#Various-utilities">Various utilities</a><a id="Various-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Various-utilities" title="Permalink"></a></h1><p>You may find these utilities useful for debugging and optimization.</p><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.stresstest" href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stresstest(f, ℓ; N, rng, scale)
</code></pre><p>Test <code>ℓ</code> with random values.</p><p><code>N</code> random vectors are drawn from a standard multivariate Cauchy distribution, scaled with <code>scale</code> (which can be a scalar or a conformable vector).</p><p>Each random vector is then used as an argument in <code>f(ℓ, ...)</code>. <code>logdensity</code> and <code>logdensity_and_gradient</code> are  recommended for <code>f</code>.</p><p>In case the call produces an error, the value is recorded as a failure, which are returned by the function.</p><p>Not exported, but part of the API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.benchmark_ForwardDiff_chunks" href="#LogDensityProblems.benchmark_ForwardDiff_chunks"><code>LogDensityProblems.benchmark_ForwardDiff_chunks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">benchmark_ForwardDiff_chunks(ℓ; chunks, markprogress, x)
</code></pre><p>Benchmark a log density problem with various chunk sizes using ForwardDiff.</p><p><code>chunks</code>, which defaults to all possible chunk sizes, determines the chunks that are tried.</p><p>The function returns <code>chunk =&gt; time</code> pairs, where <code>time</code> is the benchmarked runtime in seconds, as determined by <code>BenchmarkTools.@belapsed</code>. The gradient is evaluated at <code>x</code> (defaults to zeros).</p><p><em>Runtime may be long</em> because of tuned benchmarks, so when <code>markprogress == true</code> (the default), dots are printed to mark progress.</p><p>This function is not exported, but part of the API when <code>ForwardDiff</code> is imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/AD_ForwardDiff.jl#L69">source</a></section></article><h1 id="log-density-api"><a class="docs-heading-anchor" href="#log-density-api">Log densities API</a><a id="log-density-api-1"></a><a class="docs-heading-anchor-permalink" href="#log-density-api" title="Permalink"></a></h1><p>Use the functions below for evaluating gradients and querying their dimension and other information. These symbols are not exported, as they are mostly used by package developers and in any case would need to be <code>import</code>ed or qualified to add methods to.</p><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.capabilities" href="#LogDensityProblems.capabilities"><code>LogDensityProblems.capabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">capabilities(T)
</code></pre><p>Test if the type (or a value, for convenience) supports the log density interface.</p><p>When <code>nothing</code> is returned, it doesn&#39;t support this interface.  When <code>LogDensityOrder{K}()</code> is returned (typically with <code>K == 0</code> or <code>K = 1</code>), derivatives up to order <code>K</code> are supported. <em>All other return values are invalid</em>.</p><p><strong>Interface description</strong></p><p>The following methods need to be implemented for the interface:</p><ol><li><p><a href="#LogDensityProblems.dimension"><code>dimension</code></a> returns the <em>dimension</em> of the domain,</p></li><li><p><a href="#LogDensityProblems.logdensity"><code>logdensity</code></a> evaluates the log density at a given point.</p></li><li><p><a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a> when <code>K ≥ 1</code>.</p></li></ol><p>See also <a href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> for stress testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.LogDensityOrder" href="#LogDensityProblems.LogDensityOrder"><code>LogDensityProblems.LogDensityOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LogDensityOrder{K}</code></pre><p>A trait that means that a log density supports evaluating derivatives up to order <code>K</code>.</p><p>Typical values for <code>K</code> are <code>0</code> (just the log density) and <code>1</code> (log density and gradient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.dimension" href="#LogDensityProblems.dimension"><code>LogDensityProblems.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dimension(ℓ)</code></pre><p>Dimension of the input vectors <code>x</code> for log density <code>ℓ</code>. See <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>, <a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is <em>distinct</em> from <code>TransformedVariables.dimension</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.logdensity" href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logdensity(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return a real number, which may or may not be finite (can also be <code>NaN</code>). Non-finite values other than <code>-Inf</code> are invalid but do not error, caller should deal with these appropriately.</p><p><strong>Note about constants</strong></p><p>Log densities can be shifted by <em>the same constant</em>, as long as it is consistent between calls. For example,</p><pre><code class="language-julia">logdensity(::StandardMultivariateNormal) = -0.5 * sum(abs2, x)</code></pre><p>is a valid implementation for some callable <code>StandardMultivariateNormal</code> that would implement the standard multivariate normal distribution (dimension <span>$k$</span>) with pdf</p><p class="math-container">\[(2\pi)^{-k/2} e^{-x&#39;x/2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L83-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogDensityProblems.logdensity_and_gradient" href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logdensity_and_gradient(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> and its gradient at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return two values:</p><ul><li><p>the log density as real number, which equivalent to <code>logdensity(ℓ, x)</code></p></li><li><p><em>if</em> the log density is finite, the gradient, an <code>::AbstractVector</code> of real numbers,  otherwise this value is arbitrary and should be ignored.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Caller may assume ownership of results, ie that the gradient vector will not be overwritten or reused for a different purpose.</p></div></div><p>The first argument (the log density) can be shifted by a constant, see the note for <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/c047c18aa662e0f0bde519bb0e5b3c11a16402a7/src/LogDensityProblems.jl#L109-L128">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Monday 5 July 2021 07:47">Monday 5 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
